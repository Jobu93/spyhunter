<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Spy Hunter – Road Scroller</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      background: #1a1a1a;
    }
    canvas {
      display: block;
      background: #2d2d2d;
      border: 2px solid #444;
    }
    .lives {
      position: absolute;
      top: 12px;
      left: 12px;
      color: #fff;
      font: bold 20px/1 sans-serif;
      text-shadow: 0 1px 2px #000;
      z-index: 1;
    }
    .timer {
      position: absolute;
      top: 12px;
      left: 50%;
      transform: translateX(-50%);
      color: #fff;
      font: bold 20px/1 sans-serif;
      text-shadow: 0 1px 2px #000;
      z-index: 1;
    }
    .score {
      position: absolute;
      top: 12px;
      right: 12px;
      color: #fff;
      font: bold 20px/1 sans-serif;
      text-shadow: 0 1px 2px #000;
      z-index: 1;
    }
    .weapon-hud {
      position: absolute;
      top: 36px;
      left: 12px;
      color: #ffeb3b;
      font: 14px/1.2 sans-serif;
      text-shadow: 0 1px 2px #000;
      z-index: 1;
    }
    .weapon-popup {
      position: absolute;
      top: 40%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #ffeb3b;
      font: bold 24px/1.2 sans-serif;
      text-shadow: 0 2px 4px #000;
      z-index: 3;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
    }
    .weapon-popup.visible { opacity: 1; }
    .game-over {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #e74c3c;
      font: bold 48px/1.2 sans-serif;
      text-shadow: 0 2px 4px #000;
      z-index: 2;
      display: none;
      text-align: center;
    }
    .game-over.visible { display: block; }
    .game-over .final-score { font-size: 24px; margin-top: 12px; color: #fff; }
    .game-over .restart-hint { font-size: 18px; margin-top: 8px; color: #aaa; }
    .get-ready {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #ffeb3b;
      font: bold 36px/1.2 sans-serif;
      text-shadow: 0 2px 4px #000;
      z-index: 2;
      pointer-events: none;
      display: none;
    }
    .get-ready.visible { display: block; }
  </style>
</head>
<body>
  <div style="position: relative;">
    <span id="livesDisplay" class="lives">Lives: 3</span>
    <span id="timerDisplay" class="timer">0:00</span>
    <span id="scoreDisplay" class="score">Score: 0</span>
    <span id="weaponDisplay" class="weapon-hud">Weapon: None</span>
    <div id="weaponPopup" class="weapon-popup"></div>
    <div id="getReady" class="get-ready">Get Ready</div>
    <div id="gameOver" class="game-over">
      Game Over<br>
      <span class="final-score" id="finalScore">Score: 0</span><br>
      <span class="restart-hint">Press Enter to Restart</span>
    </div>
    <canvas id="gameCanvas" width="600" height="800"></canvas>
  </div>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Road
    const roadWidth = canvas.width * 0.5;
    const roadLeft = (canvas.width - roadWidth) / 2;
    const roadRight = roadLeft + roadWidth;

    // Dashed lane lines (scroll downward = increase offset)
    const dashLength = 40;
    const dashGap = 30;
    const laneCount = 3;
    const laneWidth = roadWidth / laneCount;
    let dashOffset = 0;
    // Difficulty ramping: scroll speed increases every 30s
    const scrollSpeedMin = 6;
    const scrollSpeedMax = 18;
    const scrollSpeedRampIntervalMs = 30000;

    // Player car
    const playerWidth = 40;
    const playerHeight = 60;
    const playerY = canvas.height * (2 / 3);
    let playerX = canvas.width / 2 - playerWidth / 2;
    const playerSpeed = 8;
    const keys = { left: false, right: false };

    // Game state
    let lives = 3;
    let gameOver = false;
    let gameStartTime = 0;  // set on first frame
    let animationId = null;
    let flashUntil = 0;
    const flashDuration = 250;
    let invincibleUntil = 0;  // 2s invincibility after respawn
    const invincibilityDurationMs = 2000;
    let getReadyUntil = 0;  // "Get Ready" shown for 2s before game starts
    const getReadyDurationMs = 2000;

    // Enemies: types = standard, aggressive, speed
    const ENEMY_TYPES = { STANDARD: 'standard', AGGRESSIVE: 'aggressive', SPEED: 'speed' };
    const enemyColors = ['#3498db', '#f39c12', '#9b59b6', '#1abc9c', '#e67e22'];  // standard only
    const enemyWidth = 40;
    const enemyHeight = 60;
    const enemyVanDodgeSpeed = 5;   // horizontal speed when dodging van
    const enemyVanCloseMargin = 25; // start dodging when this close to van (px)
    let enemies = [];
    let nextSpawnAt = Date.now() + 1000 + Math.random() * 1000;
    // Spawn rate ramping: faster spawns over time (ms between spawns)
    const spawnIntervalMinMs = 500;
    const spawnIntervalMaxMs = 2000;

    // Bullets (weapon)
    const bulletWidth = 6;
    const bulletHeight = 16;
    const bulletSpeed = 22;  // upward, faster than scroll
    const fireCooldownMs = 340;  // ~3 bullets per second
    let bullets = [];
    let lastShotAt = 0;
    let score = 0;

    // Weapons Van
    const weaponsVanWidth = 52;
    const weaponsVanHeight = 72;
    const weaponsVanColor = '#2980b9';
    const weaponsVanSpeed = 2;  // scroll slowly toward the player
    const weaponsVanSpawnInterval = 30000;  // 30 seconds
    const weaponsVanCloseDistance = 20;  // pause when van back is 20px above player
    const weaponsVanPauseDurationMs = 3000;  // stop for 3 seconds so player can receive weapon
    let weaponsVan = null;
    let nextWeaponsVanAt = Date.now() + weaponsVanSpawnInterval;
    let weaponsVanPausedUntil = 0;  // 0 = moving; timestamp = paused until then

    // Weapon collection (player behind van for 2 seconds)
    const behindVanDistance = 30;  // max gap between van rear and player front
    const behindVanHorizontalTolerance = 20;
    let behindVanSince = 0;  // timestamp when player first got behind
    const timeToCollectMs = 2000;

    // Special weapons
    const WEAPONS = { NONE: null, OIL_SLICK: 'Oil Slick', SMOKE_SCREEN: 'Smoke Screen', MISSILES: 'Missiles' };
    let currentWeapon = null;
    let weaponUsesLeft = 0;
    const weaponPopupDuration = 1500;
    let weaponPopupUntil = 0;
    const weaponDeployPopupDuration = 500;

    // Oil Slick
    const oilSlickWidth = 50;
    const oilSlickHeight = 28;
    const oilSlickDurationMs = 5000;
    const oilSlickPoints = 150;
    let oilSlicks = [];

    // Smoke Screen
    const smokeScreenBaseRadius = 25;
    const smokeScreenMaxRadius = 55;
    const smokeScreenDurationMs = 3000;
    const smokeScreenSlowDurationMs = 2000;
    const smokeScreenSlowFactor = 0.25;  // enemy moves at 25% speed
    let smokeScreens = [];

    // Missiles
    const missileWidth = 14;
    const missileHeight = 28;
    const missileSpeed = 34;
    const missilePoints = 200;
    let missiles = [];

    // Explosions (when enemies destroyed)
    const explosionDurationMs = 400;
    let explosions = [];

    // Trees (roadside scenery)
    const treeWidth = 24;
    const treeHeight = 50;
    const treeSpawnInterval = 120;  // spawn every N px of scroll
    let trees = [];
    let scrollAccumulator = 0;

    // Draw a car-shaped vehicle (pointed front, wheel wells, tapered body)
    function drawCarShape(x, y, w, h, color, isPlayer, isVan) {
      ctx.save();
      const taper = isPlayer ? 0.35 : (isVan ? 0.15 : 0.25);  // pointed front
      const wheelWellH = Math.floor(h * 0.22);
      const wheelWellW = Math.floor(w * 0.35);
      const cabinTop = isVan ? h * 0.35 : h * 0.4;

      ctx.fillStyle = color;
      ctx.beginPath();
      // Front (pointed) – top center
      ctx.moveTo(x + w / 2, y);
      // Right front taper
      ctx.lineTo(x + w - w * taper * 0.5, y + h * 0.15);
      // Right side
      ctx.lineTo(x + w - 4, y + h - wheelWellH);
      // Right wheel well
      ctx.lineTo(x + w - wheelWellW, y + h - wheelWellH);
      ctx.lineTo(x + w - wheelWellW, y + h);
      ctx.lineTo(x + wheelWellW, y + h);
      ctx.lineTo(x + wheelWellW, y + h - wheelWellH);
      // Left side
      ctx.lineTo(x + 4, y + h - wheelWellH);
      ctx.lineTo(x + w * taper * 0.5, y + h * 0.15);
      ctx.closePath();
      ctx.fill();

      // Wheel wells (darker)
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillRect(x + 3, y + h - wheelWellH, wheelWellW - 3, wheelWellH + 2);
      ctx.fillRect(x + w - wheelWellW, y + h - wheelWellH, wheelWellW - 3, wheelWellH + 2);

      // Cabin/windshield (lighter tint)
      ctx.fillStyle = isVan ? 'rgba(200,220,255,0.4)' : 'rgba(255,255,255,0.25)';
      ctx.beginPath();
      ctx.moveTo(x + w * 0.3, y + cabinTop);
      ctx.lineTo(x + w * 0.7, y + cabinTop);
      ctx.lineTo(x + w * 0.65, y + h * 0.55);
      ctx.lineTo(x + w * 0.35, y + h * 0.55);
      ctx.closePath();
      ctx.fill();

      ctx.restore();
    }

    function drawRoad() {
      const rumbleWidth = 14;
      // Green roadside – left (before rumble)
      ctx.fillStyle = '#2d5a27';
      ctx.fillRect(0, 0, roadLeft - rumbleWidth, canvas.height);
      // Green roadside – right (after rumble)
      ctx.fillStyle = '#2d5a27';
      ctx.fillRect(roadRight + rumbleWidth, 0, canvas.width - roadRight - rumbleWidth, canvas.height);

      // Dark gray rumble strips (between road edge and green)
      ctx.fillStyle = '#3a3a3a';
      ctx.fillRect(roadLeft - rumbleWidth, 0, rumbleWidth, canvas.height);
      ctx.fillRect(roadRight, 0, rumbleWidth, canvas.height);

      // Gray road
      ctx.fillStyle = '#4a4a4a';
      ctx.fillRect(roadLeft, 0, roadWidth, canvas.height);

      // Subtle darker center line (solid)
      ctx.strokeStyle = '#353535';
      ctx.lineWidth = 6;
      ctx.beginPath();
      ctx.moveTo(canvas.width / 2, 0);
      ctx.lineTo(canvas.width / 2, canvas.height);
      ctx.stroke();

      // White dashed lane lines (vertical, scrolling)
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 4;
      ctx.setLineDash([dashLength, dashGap]);
      ctx.lineDashOffset = -dashOffset;

      for (let i = 1; i < laneCount; i++) {
        const x = roadLeft + i * laneWidth;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }
      ctx.setLineDash([]);
    }

    function drawPlayer() {
      const now = Date.now();
      const isInvincible = now < invincibleUntil;
      const blink = isInvincible && Math.floor(now / 100) % 2 === 0;
      if (blink) return;  // blink = don't draw (flash effect)
      drawCarShape(playerX, playerY, playerWidth, playerHeight, '#ffffff', true, false);
    }

    // Difficulty helpers: elapsed in seconds
    function getCurrentScrollSpeed(elapsedSec) {
      const steps = Math.floor(elapsedSec / 30);
      const increment = 2;  // +2 every 30s
      return Math.min(scrollSpeedMax, scrollSpeedMin + steps * increment);
    }
    function getSpawnIntervalMs(elapsedSec) {
      const steps = Math.floor(elapsedSec / 30);
      const decrease = 250;  // -250ms every 30s
      const interval = spawnIntervalMaxMs - steps * decrease;
      return Math.max(spawnIntervalMinMs, Math.min(spawnIntervalMaxMs, interval));
    }
    // Enemy type picker: returns 'standard', 'aggressive', or 'speed'
    function pickEnemyType(elapsedSec) {
      if (elapsedSec < 30) return ENEMY_TYPES.STANDARD;
      const r = Math.random();
      let aggressiveChance = 0.25 + Math.min(0.2, (elapsedSec - 30) / 180 * 0.2);  // 25% -> ~45% over time
      let speedChance = 0;
      if (elapsedSec >= 60) {
        speedChance = 0.2 + Math.min(0.15, (elapsedSec - 60) / 180 * 0.15);  // 20% -> ~35% over time
      }
      if (r < speedChance) return ENEMY_TYPES.SPEED;
      if (r < speedChance + aggressiveChance) return ENEMY_TYPES.AGGRESSIVE;
      return ENEMY_TYPES.STANDARD;
    }
    function spawnEnemy(currentScrollSpeed, elapsedSec) {
      const lane = Math.floor(Math.random() * laneCount);
      const laneCenterX = roadLeft + lane * laneWidth + laneWidth / 2;
      const x = Math.max(roadLeft, Math.min(roadRight - enemyWidth, laneCenterX - enemyWidth / 2));
      const type = pickEnemyType(elapsedSec);
      let speed, color;
      if (type === ENEMY_TYPES.STANDARD) {
        speed = currentScrollSpeed;
        color = enemyColors[Math.floor(Math.random() * enemyColors.length)];
      } else if (type === ENEMY_TYPES.AGGRESSIVE) {
        speed = currentScrollSpeed * 0.85;  // slower than road
        color = '#c0392b';  // red
      } else {
        speed = currentScrollSpeed * 1.7;   // significantly faster
        color = '#f1c40f';  // yellow
      }
      enemies.push({ x, y: -enemyHeight, width: enemyWidth, height: enemyHeight, speed, color, baseSpeed: speed, slowedUntil: 0, type });
    }

    function drawEnemies() {
      enemies.forEach(e => {
        drawCarShape(e.x, e.y, e.width, e.height, e.color, false, false);
      });
    }

    function spawnWeaponsVan() {
      const centerLane = 1;  // middle lane
      const laneCenterX = roadLeft + centerLane * laneWidth + laneWidth / 2;
      const x = Math.max(roadLeft, Math.min(roadRight - weaponsVanWidth, laneCenterX - weaponsVanWidth / 2));
      weaponsVan = { x, y: -weaponsVanHeight, width: weaponsVanWidth, height: weaponsVanHeight, speed: weaponsVanSpeed };
    }

    function drawWeaponsVan() {
      if (!weaponsVan) return;
      drawCarShape(weaponsVan.x, weaponsVan.y, weaponsVan.width, weaponsVan.height, weaponsVanColor, false, true);
    }

    function drawBullets() {
      ctx.fillStyle = '#ffeb3b';
      bullets.forEach(b => {
        ctx.fillRect(b.x, b.y, b.width, b.height);
      });
    }

    function drawOilSlicks() {
      oilSlicks.forEach(o => {
        ctx.fillStyle = '#2d1f0f';
        ctx.strokeStyle = '#1a1208';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.ellipse(o.x + o.width / 2, o.y + o.height / 2, o.width / 2, o.height / 2, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
      });
    }

    function drawSmokeScreens() {
      smokeScreens.forEach(s => {
        const elapsed = (Date.now() - s.spawnTime) / smokeScreenDurationMs;
        const radius = smokeScreenBaseRadius + (smokeScreenMaxRadius - smokeScreenBaseRadius) * Math.min(1, elapsed);
        const alpha = 1 - elapsed * 0.7;
        ctx.fillStyle = `rgba(100, 100, 100, ${alpha})`;
        ctx.beginPath();
        ctx.arc(s.x, s.y, radius, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    function drawMissiles() {
      missiles.forEach(m => {
        ctx.fillStyle = '#e74c3c';
        ctx.fillRect(m.x, m.y, m.width, m.height);
      });
    }

    function drawFlash() {
      if (Date.now() < flashUntil) {
        ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
    }

    function spawnExplosion(x, y) {
      explosions.push({ x, y, spawnTime: Date.now() });
    }

    function drawExplosions() {
      const now = Date.now();
      explosions.forEach(ex => {
        const elapsed = (now - ex.spawnTime) / explosionDurationMs;
        if (elapsed >= 1) return;
        const radius = 20 + elapsed * 35;
        const alpha = 1 - elapsed;
        ctx.fillStyle = `rgba(255, ${Math.floor(100 + 55 * (1 - elapsed))}, 0, ${alpha})`;
        ctx.beginPath();
        ctx.arc(ex.x, ex.y, radius, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    function drawTrees() {
      trees.forEach(t => {
        const trunkH = treeHeight * 0.5;
        ctx.fillStyle = '#5d4037';
        ctx.fillRect(t.x, t.y + treeHeight - trunkH, treeWidth * 0.5, trunkH);
        ctx.fillStyle = '#2d5a27';
        ctx.beginPath();
        ctx.arc(t.x + treeWidth * 0.25, t.y + treeHeight * 0.4, treeWidth * 0.6, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    function collides(a, b) {
      return a.x < b.x + b.width && a.x + a.width > b.x &&
             a.y < b.y + b.height && a.y + a.height > b.y;
    }

    function update() {
      const now = Date.now();
      if (gameOver) {
        return;
      }
      if (gameStartTime === 0) {
        gameStartTime = now;
        getReadyUntil = now + getReadyDurationMs;
      }
      const elapsedMs = now - gameStartTime;
      const elapsedSec = elapsedMs / 1000;
      const inGetReady = now < getReadyUntil;
      document.getElementById('getReady').classList.toggle('visible', inGetReady);
      if (inGetReady) {
        if (keys.left) playerX -= playerSpeed;
        if (keys.right) playerX += playerSpeed;
        playerX = Math.max(roadLeft, Math.min(roadRight - playerWidth, playerX));
        return;
      }
      const currentScrollSpeed = getCurrentScrollSpeed(elapsedSec);
      dashOffset = (dashOffset + currentScrollSpeed) % (dashLength + dashGap);
      document.getElementById('timerDisplay').textContent = Math.floor(elapsedSec / 60) + ':' + String(Math.floor(elapsedSec % 60)).padStart(2, '0');

      // Update explosions: scroll with road, remove when expired
      for (let i = explosions.length - 1; i >= 0; i--) {
        explosions[i].y += currentScrollSpeed;
        if (now - explosions[i].spawnTime >= explosionDurationMs || explosions[i].y > canvas.height) {
          explosions.splice(i, 1);
        }
      }

      // Spawn and scroll trees
      scrollAccumulator += currentScrollSpeed;
      const rumbleWidth = 14;
      while (scrollAccumulator >= treeSpawnInterval) {
        scrollAccumulator -= treeSpawnInterval;
        const leftX = 15 + Math.random() * (roadLeft - rumbleWidth - treeWidth - 30);
        const rightX = roadRight + rumbleWidth + 15 + Math.random() * (canvas.width - roadRight - rumbleWidth - treeWidth - 30);
        trees.push({ x: leftX, y: -treeHeight, width: treeWidth, height: treeHeight });
        trees.push({ x: rightX, y: -treeHeight, width: treeWidth, height: treeHeight });
      }
      for (let i = trees.length - 1; i >= 0; i--) {
        trees[i].y += currentScrollSpeed;
        if (trees[i].y > canvas.height) trees.splice(i, 1);
      }

      if (keys.left) playerX -= playerSpeed;
      if (keys.right) playerX += playerSpeed;
      playerX = Math.max(roadLeft, Math.min(roadRight - playerWidth, playerX));

      // Spawn weapons van every 30 seconds
      if (!weaponsVan && now >= nextWeaponsVanAt) {
        spawnWeaponsVan();
        nextWeaponsVanAt = now + weaponsVanSpawnInterval;
      }

      // Move weapons van: scroll slowly; when very close to player, pause 3s then resume
      if (weaponsVan) {
        const vanBack = weaponsVan.y + weaponsVan.height;
        const playerFront = playerY;
        const gapAbovePlayer = playerFront - vanBack;
        const isVeryClose = gapAbovePlayer >= -20 && gapAbovePlayer <= weaponsVanCloseDistance;

        if (isVeryClose && weaponsVanPausedUntil === 0) {
          weaponsVanPausedUntil = now + weaponsVanPauseDurationMs;
        }
        if (now < weaponsVanPausedUntil) {
          // paused: don't move
        } else {
          weaponsVan.y += weaponsVan.speed;
        }
        if (weaponsVan.y > canvas.height) {
          weaponsVan = null;
          behindVanSince = 0;
          weaponsVanPausedUntil = 0;
        }
      } else {
        weaponsVanPausedUntil = 0;
      }

      // Spawn enemies: interval decreases as difficulty ramps
      if (now >= nextSpawnAt) {
        const spawnInterval = getSpawnIntervalMs(elapsedSec);
        spawnEnemy(currentScrollSpeed, elapsedSec);
        nextSpawnAt = now + spawnInterval * 0.5 + Math.random() * spawnInterval * 0.5;
      }

      // Move bullets upward; remove if off top
      for (let i = bullets.length - 1; i >= 0; i--) {
        bullets[i].y -= bulletSpeed;
        if (bullets[i].y + bullets[i].height < 0) {
          bullets.splice(i, 1);
        }
      }

      // Bullet–enemy collision (destroy enemy, remove bullet, add score)
      for (let b = bullets.length - 1; b >= 0; b--) {
        for (let e = enemies.length - 1; e >= 0; e--) {
          if (collides(bullets[b], enemies[e])) {
            spawnExplosion(enemies[e].x + enemies[e].width / 2, enemies[e].y + enemies[e].height / 2);
            score += 100;
            document.getElementById('scoreDisplay').textContent = 'Score: ' + score;
            enemies.splice(e, 1);
            bullets.splice(b, 1);
            break;
          }
        }
      }

      // Missile–enemy collision (destroy enemy, remove missile, 200 points)
      for (let m = missiles.length - 1; m >= 0; m--) {
        for (let e = enemies.length - 1; e >= 0; e--) {
          if (collides(missiles[m], enemies[e])) {
            spawnExplosion(enemies[e].x + enemies[e].width / 2, enemies[e].y + enemies[e].height / 2);
            score += missilePoints;
            document.getElementById('scoreDisplay').textContent = 'Score: ' + score;
            enemies.splice(e, 1);
            missiles.splice(m, 1);
            break;
          }
        }
      }

      // Oil slick: scroll with road, remove expired, destroy enemies that drive over
      for (let i = oilSlicks.length - 1; i >= 0; i--) {
        oilSlicks[i].y += currentScrollSpeed;
        if (oilSlicks[i].y > canvas.height || now - oilSlicks[i].spawnTime >= oilSlickDurationMs) {
          oilSlicks.splice(i, 1);
          continue;
        }
        for (let e = enemies.length - 1; e >= 0; e--) {
          if (collides(oilSlicks[i], enemies[e])) {
            spawnExplosion(enemies[e].x + enemies[e].width / 2, enemies[e].y + enemies[e].height / 2);
            score += oilSlickPoints;
            document.getElementById('scoreDisplay').textContent = 'Score: ' + score;
            enemies.splice(e, 1);
            oilSlicks.splice(i, 1);
            break;
          }
        }
      }

      // Smoke screen: scroll with road, remove expired; slow enemies that enter
      for (let i = smokeScreens.length - 1; i >= 0; i--) {
        const s = smokeScreens[i];
        s.y += currentScrollSpeed;
        if (now - s.spawnTime >= smokeScreenDurationMs || s.y > canvas.height) {
          smokeScreens.splice(i, 1);
          continue;
        }
        const elapsed = (now - s.spawnTime) / smokeScreenDurationMs;
        const radius = smokeScreenBaseRadius + (smokeScreenMaxRadius - smokeScreenBaseRadius) * Math.min(1, elapsed);
        enemies.forEach(e => {
          const ex = e.x + e.width / 2;
          const ey = e.y + e.height / 2;
          const dist = Math.hypot(ex - s.x, ey - s.y);
          if (dist < radius && now > (e.slowedUntil || 0)) {
            e.slowedUntil = now + smokeScreenSlowDurationMs;
            if (!e.baseSpeed) e.baseSpeed = e.speed;
          }
        });
      }

      // Move missiles upward; remove if off top
      for (let i = missiles.length - 1; i >= 0; i--) {
        missiles[i].y -= missileSpeed;
        if (missiles[i].y + missiles[i].height < 0) {
          missiles.splice(i, 1);
        }
      }

      // Move enemies (remove if off bottom); apply smoke slow; dodge weapons van
      const playerRect = { x: playerX, y: playerY, width: playerWidth, height: playerHeight };
      for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        const effectiveSpeed = (e.slowedUntil && now < e.slowedUntil) ? (e.baseSpeed || e.speed) * smokeScreenSlowFactor : e.speed;

        // Check if enemy is close to weapons van and would overlap it if we moved down
        const wouldOverlapVan = weaponsVan && (() => {
          const eNextY = e.y + effectiveSpeed;
          const van = weaponsVan;
          const verticalClose = (eNextY + e.height >= van.y - enemyVanCloseMargin) && (eNextY <= van.y + van.height + enemyVanCloseMargin);
          const horizontalOverlap = e.x < van.x + van.width && e.x + e.width > van.x;
          return verticalClose && horizontalOverlap;
        })();

        if (wouldOverlapVan) {
          // Dodge sideways: move away from van center, stay on road
          const vanCenter = weaponsVan.x + weaponsVan.width / 2;
          const enemyCenter = e.x + e.width / 2;
          if (enemyCenter < vanCenter) {
            e.x = Math.max(roadLeft, e.x - enemyVanDodgeSpeed);
          } else {
            e.x = Math.min(roadRight - e.width, e.x + enemyVanDodgeSpeed);
          }
        } else {
          e.y += effectiveSpeed;
          // Aggressive cars: steer toward player's lane
          if (e.type === ENEMY_TYPES.AGGRESSIVE) {
            const playerCenter = playerX + playerWidth / 2;
            const enemyCenter = e.x + e.width / 2;
            const steerSpeed = 3;  // horizontal tracking speed
            if (enemyCenter < playerCenter - 5) {
              e.x = Math.min(roadRight - e.width, e.x + steerSpeed);
            } else if (enemyCenter > playerCenter + 5) {
              e.x = Math.max(roadLeft, e.x - steerSpeed);
            }
          }
        }

        if (enemies[i].y > canvas.height) {
          enemies.splice(i, 1);
          continue;
        }
        if (!(now < invincibleUntil) && collides(playerRect, enemies[i])) {
          flashUntil = Date.now() + flashDuration;
          invincibleUntil = Date.now() + invincibilityDurationMs;
          playerX = canvas.width / 2 - playerWidth / 2;
          lives--;
          document.getElementById('livesDisplay').textContent = 'Lives: ' + lives;
          enemies.splice(i, 1);
          if (lives <= 0) {
            gameOver = true;
            document.getElementById('finalScore').textContent = 'Score: ' + score;
            document.getElementById('gameOver').classList.add('visible');
            return;
          }
        }
      }

      // Weapons van collision: block movement like a wall, no damage
      if (weaponsVan && collides(playerRect, weaponsVan)) {
        const playerCenter = playerX + playerWidth / 2;
        const vanCenter = weaponsVan.x + weaponsVan.width / 2;
        if (playerCenter < vanCenter) {
          playerX = weaponsVan.x - playerWidth - 1;
        } else {
          playerX = weaponsVan.x + weaponsVan.width + 1;
        }
        playerX = Math.max(roadLeft, Math.min(roadRight - playerWidth, playerX));
      }

      // Weapon collection: player behind van for 2 seconds
      if (weaponsVan) {
        const vanBack = weaponsVan.y + weaponsVan.height;
        const playerFront = playerY;
        const verticalGap = playerFront - vanBack;
        const horizontalOverlap = Math.abs((playerX + playerWidth / 2) - (weaponsVan.x + weaponsVan.width / 2)) < weaponsVan.width / 2 + behindVanHorizontalTolerance;
        const isBehind = verticalGap >= 0 && verticalGap <= behindVanDistance && horizontalOverlap;

        if (isBehind) {
          if (behindVanSince === 0) behindVanSince = now;
          if (now - behindVanSince >= timeToCollectMs) {
            const choices = [WEAPONS.OIL_SLICK, WEAPONS.SMOKE_SCREEN, WEAPONS.MISSILES];
            currentWeapon = choices[Math.floor(Math.random() * choices.length)];
            weaponUsesLeft = 3;
            behindVanSince = 0;
            weaponsVan = null;
            document.getElementById('weaponDisplay').textContent = currentWeapon + ': 3';
            const popup = document.getElementById('weaponPopup');
            popup.textContent = currentWeapon + ' Acquired!';
            popup.classList.add('visible');
            weaponPopupUntil = now + weaponPopupDuration;
          }
        } else {
          behindVanSince = 0;
        }
      } else {
        behindVanSince = 0;
      }

      // Hide weapon popup after duration
      if (now >= weaponPopupUntil) {
        document.getElementById('weaponPopup').classList.remove('visible');
      }
    }

    function gameLoop() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawRoad();
      drawTrees();
      drawOilSlicks();
      drawSmokeScreens();
      drawEnemies();
      drawWeaponsVan();
      drawBullets();
      drawMissiles();
      drawPlayer();
      drawExplosions();
      drawFlash();
      update();
      if (!gameOver) animationId = requestAnimationFrame(gameLoop);
    }

    function resetGame() {
      lives = 3;
      gameOver = false;
      gameStartTime = 0;
      getReadyUntil = 0;
      invincibleUntil = 0;
      dashOffset = 0;
      scrollAccumulator = 0;
      playerX = canvas.width / 2 - playerWidth / 2;
      enemies = [];
      bullets = [];
      missiles = [];
      oilSlicks = [];
      smokeScreens = [];
      explosions = [];
      trees = [];
      weaponsVan = null;
      behindVanSince = 0;
      weaponsVanPausedUntil = 0;
      currentWeapon = null;
      weaponUsesLeft = 0;
      weaponPopupUntil = 0;
      score = 0;
      nextSpawnAt = Date.now() + 1000 + Math.random() * 1000;
      nextWeaponsVanAt = Date.now() + weaponsVanSpawnInterval;
      document.getElementById('livesDisplay').textContent = 'Lives: ' + lives;
      document.getElementById('timerDisplay').textContent = '0:00';
      document.getElementById('scoreDisplay').textContent = 'Score: ' + score;
      document.getElementById('weaponDisplay').textContent = 'Weapon: None';
      document.getElementById('weaponPopup').classList.remove('visible');
      document.getElementById('getReady').classList.remove('visible');
      document.getElementById('gameOver').classList.remove('visible');
      if (animationId) cancelAnimationFrame(animationId);
      animationId = requestAnimationFrame(gameLoop);
    }

    function fireBullet() {
      if (gameOver) return;
      const now = Date.now();
      if (gameStartTime > 0 && now < getReadyUntil) return;
      if (now - lastShotAt < fireCooldownMs) return;
      lastShotAt = now;
      const x = playerX + playerWidth / 2 - bulletWidth / 2;
      const y = playerY;
      bullets.push({ x, y, width: bulletWidth, height: bulletHeight });
    }

    function useWeapon(key) {
      if (gameOver) return;
      const now = Date.now();
      if (gameStartTime > 0 && now < getReadyUntil) return;
      if (!currentWeapon || weaponUsesLeft <= 0) return;
      const expected = { o: WEAPONS.OIL_SLICK, s: WEAPONS.SMOKE_SCREEN, m: WEAPONS.MISSILES };
      if (currentWeapon !== expected[key]) return;
      weaponUsesLeft--;
      const hud = document.getElementById('weaponDisplay');
      const popup = document.getElementById('weaponPopup');
      if (weaponUsesLeft <= 0) {
        currentWeapon = null;
        hud.textContent = 'Weapon: None';
      } else {
        hud.textContent = currentWeapon + ': ' + weaponUsesLeft;
      }
      if (key === 'o') {
        const x = playerX + playerWidth / 2 - oilSlickWidth / 2;
        const y = playerY + playerHeight;
        oilSlicks.push({ x, y, width: oilSlickWidth, height: oilSlickHeight, spawnTime: now });
        popup.textContent = 'Oil Slick!';
      } else if (key === 's') {
        const x = playerX + playerWidth / 2;
        const y = playerY + playerHeight;
        smokeScreens.push({ x, y, spawnTime: now });
        popup.textContent = 'Smoke Screen!';
      } else if (key === 'm') {
        const x = playerX + playerWidth / 2 - missileWidth / 2;
        const y = playerY;
        missiles.push({ x, y, width: missileWidth, height: missileHeight });
        popup.textContent = 'Missiles!';
      }
      popup.classList.add('visible');
      weaponPopupUntil = now + weaponDeployPopupDuration;
    }

    document.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && gameOver) { resetGame(); e.preventDefault(); return; }
      if (e.key === 'ArrowLeft') { keys.left = true; e.preventDefault(); }
      if (e.key === 'ArrowRight') { keys.right = true; e.preventDefault(); }
      if (e.key === ' ') { fireBullet(); e.preventDefault(); }
      if (e.key === 'o' || e.key === 'O') { useWeapon('o'); e.preventDefault(); }
      if (e.key === 's' || e.key === 'S') { useWeapon('s'); e.preventDefault(); }
      if (e.key === 'm' || e.key === 'M') { useWeapon('m'); e.preventDefault(); }
    });
    document.addEventListener('keyup', (e) => {
      if (e.key === 'ArrowLeft') keys.left = false;
      if (e.key === 'ArrowRight') keys.right = false;
    });

    gameLoop();
  </script>
</body>
</html>
