<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Spy Hunter – Road Scroller</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      background: #1a1a1a;
    }
    canvas {
      display: block;
      background: #2d2d2d;
      border: 2px solid #444;
    }
    .lives {
      position: absolute;
      top: 12px;
      left: 12px;
      color: #fff;
      font: bold 20px/1 sans-serif;
      text-shadow: 0 1px 2px #000;
      z-index: 1;
    }
    .score {
      position: absolute;
      top: 12px;
      right: 12px;
      color: #fff;
      font: bold 20px/1 sans-serif;
      text-shadow: 0 1px 2px #000;
      z-index: 1;
    }
    .weapon-hud {
      position: absolute;
      top: 36px;
      left: 12px;
      color: #ffeb3b;
      font: 14px/1.2 sans-serif;
      text-shadow: 0 1px 2px #000;
      z-index: 1;
    }
    .weapon-popup {
      position: absolute;
      top: 40%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #ffeb3b;
      font: bold 24px/1.2 sans-serif;
      text-shadow: 0 2px 4px #000;
      z-index: 3;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
    }
    .weapon-popup.visible { opacity: 1; }
    .game-over {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #e74c3c;
      font: bold 48px/1.2 sans-serif;
      text-shadow: 0 2px 4px #000;
      z-index: 2;
      display: none;
    }
    .game-over.visible { display: block; }
  </style>
</head>
<body>
  <div style="position: relative;">
    <span id="livesDisplay" class="lives">Lives: 3</span>
    <span id="scoreDisplay" class="score">Score: 0</span>
    <span id="weaponDisplay" class="weapon-hud">Weapon: None</span>
    <div id="weaponPopup" class="weapon-popup"></div>
    <div id="gameOver" class="game-over">Game Over</div>
    <canvas id="gameCanvas" width="600" height="800"></canvas>
  </div>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Road
    const roadWidth = canvas.width * 0.5;
    const roadLeft = (canvas.width - roadWidth) / 2;
    const roadRight = roadLeft + roadWidth;

    // Dashed lane lines (scroll downward = increase offset)
    const dashLength = 40;
    const dashGap = 30;
    const laneCount = 3;
    const laneWidth = roadWidth / laneCount;
    let dashOffset = 0;
    const scrollSpeed = 10;

    // Player car
    const playerWidth = 40;
    const playerHeight = 60;
    const playerY = canvas.height * (2 / 3);
    let playerX = canvas.width / 2 - playerWidth / 2;
    const playerSpeed = 8;
    const keys = { left: false, right: false };

    // Game state
    let lives = 3;
    let gameOver = false;
    let animationId = null;
    let flashUntil = 0;
    const flashDuration = 250;

    // Enemies
    const enemyColors = ['#3498db', '#f39c12', '#9b59b6', '#1abc9c', '#e67e22'];
    const enemyWidth = 40;
    const enemyHeight = 60;
    const enemySpeedVariation = 3;  // ± from scrollSpeed
    let enemies = [];
    let nextSpawnAt = Date.now() + 1000 + Math.random() * 1000;

    // Bullets (weapon)
    const bulletWidth = 6;
    const bulletHeight = 16;
    const bulletSpeed = 22;  // upward, faster than scroll
    const fireCooldownMs = 340;  // ~3 bullets per second
    let bullets = [];
    let lastShotAt = 0;
    let score = 0;

    // Weapons Van
    const weaponsVanWidth = 52;
    const weaponsVanHeight = 72;
    const weaponsVanColor = '#2980b9';
    const weaponsVanSpeed = 2;  // scroll slowly toward the player
    const weaponsVanSpawnInterval = 30000;  // 30 seconds
    const weaponsVanCloseDistance = 20;  // pause when van back is 20px above player
    const weaponsVanPauseDurationMs = 3000;  // stop for 3 seconds so player can receive weapon
    let weaponsVan = null;
    let nextWeaponsVanAt = Date.now() + weaponsVanSpawnInterval;
    let weaponsVanPausedUntil = 0;  // 0 = moving; timestamp = paused until then

    // Weapon collection (player behind van for 2 seconds)
    const behindVanDistance = 30;  // max gap between van rear and player front
    const behindVanHorizontalTolerance = 20;
    let behindVanSince = 0;  // timestamp when player first got behind
    const timeToCollectMs = 2000;

    // Special weapons
    const WEAPONS = { NONE: null, OIL_SLICK: 'Oil Slick', SMOKE_SCREEN: 'Smoke Screen', MISSILES: 'Missiles' };
    let currentWeapon = null;
    let weaponUsesLeft = 0;
    const weaponPopupDuration = 1500;
    let weaponPopupUntil = 0;

    function drawRoad() {
      // Green roadside – left
      ctx.fillStyle = '#2d5a27';
      ctx.fillRect(0, 0, roadLeft, canvas.height);
      // Green roadside – right
      ctx.fillStyle = '#2d5a27';
      ctx.fillRect(roadRight, 0, canvas.width - roadRight, canvas.height);

      // Gray road
      ctx.fillStyle = '#4a4a4a';
      ctx.fillRect(roadLeft, 0, roadWidth, canvas.height);

      // White dashed lane lines (vertical, scrolling)
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 4;
      ctx.setLineDash([dashLength, dashGap]);
      ctx.lineDashOffset = -dashOffset;

      for (let i = 1; i < laneCount; i++) {
        const x = roadLeft + i * laneWidth;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }
      ctx.setLineDash([]);
    }

    function drawPlayer() {
      ctx.fillStyle = '#e74c3c';
      ctx.fillRect(playerX, playerY, playerWidth, playerHeight);
    }

    function spawnEnemy() {
      const lane = Math.floor(Math.random() * laneCount);
      const laneCenterX = roadLeft + lane * laneWidth + laneWidth / 2;
      const x = Math.max(roadLeft, Math.min(roadRight - enemyWidth, laneCenterX - enemyWidth / 2));
      const speed = scrollSpeed + (Math.random() * 2 - 1) * enemySpeedVariation;
      const color = enemyColors[Math.floor(Math.random() * enemyColors.length)];
      enemies.push({ x, y: -enemyHeight, width: enemyWidth, height: enemyHeight, speed, color });
    }

    function drawEnemies() {
      enemies.forEach(e => {
        ctx.fillStyle = e.color;
        ctx.fillRect(e.x, e.y, e.width, e.height);
      });
    }

    function spawnWeaponsVan() {
      const centerLane = 1;  // middle lane
      const laneCenterX = roadLeft + centerLane * laneWidth + laneWidth / 2;
      const x = Math.max(roadLeft, Math.min(roadRight - weaponsVanWidth, laneCenterX - weaponsVanWidth / 2));
      weaponsVan = { x, y: -weaponsVanHeight, width: weaponsVanWidth, height: weaponsVanHeight, speed: weaponsVanSpeed };
    }

    function drawWeaponsVan() {
      if (!weaponsVan) return;
      ctx.fillStyle = weaponsVanColor;
      ctx.fillRect(weaponsVan.x, weaponsVan.y, weaponsVan.width, weaponsVan.height);
    }

    function drawBullets() {
      ctx.fillStyle = '#ffeb3b';
      bullets.forEach(b => {
        ctx.fillRect(b.x, b.y, b.width, b.height);
      });
    }

    function drawFlash() {
      if (Date.now() < flashUntil) {
        ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
    }

    function collides(a, b) {
      return a.x < b.x + b.width && a.x + a.width > b.x &&
             a.y < b.y + b.height && a.y + a.height > b.y;
    }

    function update() {
      if (gameOver) return;
      dashOffset = (dashOffset + scrollSpeed) % (dashLength + dashGap);

      if (keys.left) playerX -= playerSpeed;
      if (keys.right) playerX += playerSpeed;
      playerX = Math.max(roadLeft, Math.min(roadRight - playerWidth, playerX));

      // Spawn weapons van every 30 seconds
      const now = Date.now();
      if (!weaponsVan && now >= nextWeaponsVanAt) {
        spawnWeaponsVan();
        nextWeaponsVanAt = now + weaponsVanSpawnInterval;
      }

      // Move weapons van: scroll slowly; when very close to player, pause 3s then resume
      if (weaponsVan) {
        const vanBack = weaponsVan.y + weaponsVan.height;
        const playerFront = playerY;
        const gapAbovePlayer = playerFront - vanBack;
        const isVeryClose = gapAbovePlayer >= -20 && gapAbovePlayer <= weaponsVanCloseDistance;

        if (isVeryClose && weaponsVanPausedUntil === 0) {
          weaponsVanPausedUntil = now + weaponsVanPauseDurationMs;
        }
        if (now < weaponsVanPausedUntil) {
          // paused: don't move
        } else {
          weaponsVan.y += weaponsVan.speed;
        }
        if (weaponsVan.y > canvas.height) {
          weaponsVan = null;
          behindVanSince = 0;
          weaponsVanPausedUntil = 0;
        }
      } else {
        weaponsVanPausedUntil = 0;
      }

      // Spawn enemies at random 1–2s intervals
      if (now >= nextSpawnAt) {
        spawnEnemy();
        nextSpawnAt = now + 1000 + Math.random() * 1000;
      }

      // Move bullets upward; remove if off top
      for (let i = bullets.length - 1; i >= 0; i--) {
        bullets[i].y -= bulletSpeed;
        if (bullets[i].y + bullets[i].height < 0) {
          bullets.splice(i, 1);
        }
      }

      // Bullet–enemy collision (destroy enemy, remove bullet, add score)
      for (let b = bullets.length - 1; b >= 0; b--) {
        for (let e = enemies.length - 1; e >= 0; e--) {
          if (collides(bullets[b], enemies[e])) {
            score += 100;
            document.getElementById('scoreDisplay').textContent = 'Score: ' + score;
            enemies.splice(e, 1);
            bullets.splice(b, 1);
            break;
          }
        }
      }

      // Move enemies (remove if off bottom)
      const playerRect = { x: playerX, y: playerY, width: playerWidth, height: playerHeight };
      for (let i = enemies.length - 1; i >= 0; i--) {
        enemies[i].y += enemies[i].speed;
        if (enemies[i].y > canvas.height) {
          enemies.splice(i, 1);
          continue;
        }
        if (collides(playerRect, enemies[i])) {
          flashUntil = Date.now() + flashDuration;
          playerX = canvas.width / 2 - playerWidth / 2;
          lives--;
          document.getElementById('livesDisplay').textContent = 'Lives: ' + lives;
          enemies.splice(i, 1);
          if (lives <= 0) {
            gameOver = true;
            document.getElementById('gameOver').classList.add('visible');
            return;
          }
        }
      }

      // Weapons van collision: block movement like a wall, no damage
      if (weaponsVan && collides(playerRect, weaponsVan)) {
        const playerCenter = playerX + playerWidth / 2;
        const vanCenter = weaponsVan.x + weaponsVan.width / 2;
        if (playerCenter < vanCenter) {
          playerX = weaponsVan.x - playerWidth - 1;
        } else {
          playerX = weaponsVan.x + weaponsVan.width + 1;
        }
        playerX = Math.max(roadLeft, Math.min(roadRight - playerWidth, playerX));
      }

      // Weapon collection: player behind van for 2 seconds
      if (weaponsVan) {
        const vanBack = weaponsVan.y + weaponsVan.height;
        const playerFront = playerY;
        const verticalGap = playerFront - vanBack;
        const horizontalOverlap = Math.abs((playerX + playerWidth / 2) - (weaponsVan.x + weaponsVan.width / 2)) < weaponsVan.width / 2 + behindVanHorizontalTolerance;
        const isBehind = verticalGap >= 0 && verticalGap <= behindVanDistance && horizontalOverlap;

        if (isBehind) {
          if (behindVanSince === 0) behindVanSince = now;
          if (now - behindVanSince >= timeToCollectMs) {
            const choices = [WEAPONS.OIL_SLICK, WEAPONS.SMOKE_SCREEN, WEAPONS.MISSILES];
            currentWeapon = choices[Math.floor(Math.random() * choices.length)];
            weaponUsesLeft = 3;
            behindVanSince = 0;
            weaponsVan = null;
            document.getElementById('weaponDisplay').textContent = 'Weapon: ' + currentWeapon + ' (3)';
            const popup = document.getElementById('weaponPopup');
            popup.textContent = currentWeapon + ' Acquired!';
            popup.classList.add('visible');
            weaponPopupUntil = now + weaponPopupDuration;
          }
        } else {
          behindVanSince = 0;
        }
      } else {
        behindVanSince = 0;
      }

      // Hide weapon popup after duration
      if (now >= weaponPopupUntil) {
        document.getElementById('weaponPopup').classList.remove('visible');
      }
    }

    function gameLoop() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawRoad();
      drawEnemies();
      drawWeaponsVan();
      drawBullets();
      drawPlayer();
      drawFlash();
      update();
      if (!gameOver) animationId = requestAnimationFrame(gameLoop);
    }

    function fireBullet() {
      if (gameOver) return;
      const now = Date.now();
      if (now - lastShotAt < fireCooldownMs) return;
      lastShotAt = now;
      const x = playerX + playerWidth / 2 - bulletWidth / 2;
      const y = playerY;
      bullets.push({ x, y, width: bulletWidth, height: bulletHeight });
    }

    function useWeapon(key) {
      if (gameOver) return;
      if (!currentWeapon || weaponUsesLeft <= 0) return;
      const expected = { o: WEAPONS.OIL_SLICK, s: WEAPONS.SMOKE_SCREEN, m: WEAPONS.MISSILES };
      if (currentWeapon !== expected[key]) return;
      weaponUsesLeft--;
      document.getElementById('weaponDisplay').textContent = weaponUsesLeft > 0 ? 'Weapon: ' + currentWeapon + ' (' + weaponUsesLeft + ')' : 'Weapon: None';
      if (weaponUsesLeft <= 0) currentWeapon = null;
      // Actual effects (oil slick, smoke screen, missiles) will be wired in next prompt
    }

    document.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowLeft') { keys.left = true; e.preventDefault(); }
      if (e.key === 'ArrowRight') { keys.right = true; e.preventDefault(); }
      if (e.key === ' ') { fireBullet(); e.preventDefault(); }
      if (e.key === 'o' || e.key === 'O') { useWeapon('o'); e.preventDefault(); }
      if (e.key === 's' || e.key === 'S') { useWeapon('s'); e.preventDefault(); }
      if (e.key === 'm' || e.key === 'M') { useWeapon('m'); e.preventDefault(); }
    });
    document.addEventListener('keyup', (e) => {
      if (e.key === 'ArrowLeft') keys.left = false;
      if (e.key === 'ArrowRight') keys.right = false;
    });

    gameLoop();
  </script>
</body>
</html>
