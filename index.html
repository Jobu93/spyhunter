<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Spy Hunter – Road Scroller</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      background: #1a1a1a;
    }
    canvas {
      display: block;
      background: #2d2d2d;
      border: 2px solid #444;
    }
    .lives {
      position: absolute;
      top: 12px;
      left: 12px;
      color: #fff;
      font: bold 20px/1 sans-serif;
      text-shadow: 0 1px 2px #000;
      z-index: 1;
    }
    .score {
      position: absolute;
      top: 12px;
      right: 12px;
      color: #fff;
      font: bold 20px/1 sans-serif;
      text-shadow: 0 1px 2px #000;
      z-index: 1;
    }
    .game-over {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #e74c3c;
      font: bold 48px/1.2 sans-serif;
      text-shadow: 0 2px 4px #000;
      z-index: 2;
      display: none;
    }
    .game-over.visible { display: block; }
  </style>
</head>
<body>
  <div style="position: relative;">
    <span id="livesDisplay" class="lives">Lives: 3</span>
    <span id="scoreDisplay" class="score">Score: 0</span>
    <div id="gameOver" class="game-over">Game Over</div>
    <canvas id="gameCanvas" width="600" height="800"></canvas>
  </div>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Road
    const roadWidth = canvas.width * 0.5;
    const roadLeft = (canvas.width - roadWidth) / 2;
    const roadRight = roadLeft + roadWidth;

    // Dashed lane lines (scroll downward = increase offset)
    const dashLength = 40;
    const dashGap = 30;
    const laneCount = 3;
    const laneWidth = roadWidth / laneCount;
    let dashOffset = 0;
    const scrollSpeed = 10;

    // Player car
    const playerWidth = 40;
    const playerHeight = 60;
    const playerY = canvas.height * (2 / 3);
    let playerX = canvas.width / 2 - playerWidth / 2;
    const playerSpeed = 8;
    const keys = { left: false, right: false };

    // Game state
    let lives = 3;
    let gameOver = false;
    let animationId = null;
    let flashUntil = 0;
    const flashDuration = 250;

    // Enemies
    const enemyColors = ['#3498db', '#f39c12', '#9b59b6', '#1abc9c', '#e67e22'];
    const enemyWidth = 40;
    const enemyHeight = 60;
    const enemySpeedVariation = 3;  // ± from scrollSpeed
    let enemies = [];
    let nextSpawnAt = Date.now() + 1000 + Math.random() * 1000;

    // Bullets (weapon)
    const bulletWidth = 6;
    const bulletHeight = 16;
    const bulletSpeed = 22;  // upward, faster than scroll
    const fireCooldownMs = 340;  // ~3 bullets per second
    let bullets = [];
    let lastShotAt = 0;
    let score = 0;

    function drawRoad() {
      // Green roadside – left
      ctx.fillStyle = '#2d5a27';
      ctx.fillRect(0, 0, roadLeft, canvas.height);
      // Green roadside – right
      ctx.fillStyle = '#2d5a27';
      ctx.fillRect(roadRight, 0, canvas.width - roadRight, canvas.height);

      // Gray road
      ctx.fillStyle = '#4a4a4a';
      ctx.fillRect(roadLeft, 0, roadWidth, canvas.height);

      // White dashed lane lines (vertical, scrolling)
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 4;
      ctx.setLineDash([dashLength, dashGap]);
      ctx.lineDashOffset = -dashOffset;

      for (let i = 1; i < laneCount; i++) {
        const x = roadLeft + i * laneWidth;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }
      ctx.setLineDash([]);
    }

    function drawPlayer() {
      ctx.fillStyle = '#e74c3c';
      ctx.fillRect(playerX, playerY, playerWidth, playerHeight);
    }

    function spawnEnemy() {
      const lane = Math.floor(Math.random() * laneCount);
      const laneCenterX = roadLeft + lane * laneWidth + laneWidth / 2;
      const x = Math.max(roadLeft, Math.min(roadRight - enemyWidth, laneCenterX - enemyWidth / 2));
      const speed = scrollSpeed + (Math.random() * 2 - 1) * enemySpeedVariation;
      const color = enemyColors[Math.floor(Math.random() * enemyColors.length)];
      enemies.push({ x, y: -enemyHeight, width: enemyWidth, height: enemyHeight, speed, color });
    }

    function drawEnemies() {
      enemies.forEach(e => {
        ctx.fillStyle = e.color;
        ctx.fillRect(e.x, e.y, e.width, e.height);
      });
    }

    function drawBullets() {
      ctx.fillStyle = '#ffeb3b';
      bullets.forEach(b => {
        ctx.fillRect(b.x, b.y, b.width, b.height);
      });
    }

    function drawFlash() {
      if (Date.now() < flashUntil) {
        ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
    }

    function collides(a, b) {
      return a.x < b.x + b.width && a.x + a.width > b.x &&
             a.y < b.y + b.height && a.y + a.height > b.y;
    }

    function update() {
      if (gameOver) return;
      dashOffset = (dashOffset + scrollSpeed) % (dashLength + dashGap);

      if (keys.left) playerX -= playerSpeed;
      if (keys.right) playerX += playerSpeed;
      playerX = Math.max(roadLeft, Math.min(roadRight - playerWidth, playerX));

      // Spawn enemies at random 1–2s intervals
      const now = Date.now();
      if (now >= nextSpawnAt) {
        spawnEnemy();
        nextSpawnAt = now + 1000 + Math.random() * 1000;
      }

      // Move bullets upward; remove if off top
      for (let i = bullets.length - 1; i >= 0; i--) {
        bullets[i].y -= bulletSpeed;
        if (bullets[i].y + bullets[i].height < 0) {
          bullets.splice(i, 1);
        }
      }

      // Bullet–enemy collision (destroy enemy, remove bullet, add score)
      for (let b = bullets.length - 1; b >= 0; b--) {
        for (let e = enemies.length - 1; e >= 0; e--) {
          if (collides(bullets[b], enemies[e])) {
            score += 100;
            document.getElementById('scoreDisplay').textContent = 'Score: ' + score;
            enemies.splice(e, 1);
            bullets.splice(b, 1);
            break;
          }
        }
      }

      // Move enemies (remove if off bottom)
      const playerRect = { x: playerX, y: playerY, width: playerWidth, height: playerHeight };
      for (let i = enemies.length - 1; i >= 0; i--) {
        enemies[i].y += enemies[i].speed;
        if (enemies[i].y > canvas.height) {
          enemies.splice(i, 1);
          continue;
        }
        if (collides(playerRect, enemies[i])) {
          flashUntil = Date.now() + flashDuration;
          playerX = canvas.width / 2 - playerWidth / 2;
          lives--;
          document.getElementById('livesDisplay').textContent = 'Lives: ' + lives;
          enemies.splice(i, 1);
          if (lives <= 0) {
            gameOver = true;
            document.getElementById('gameOver').classList.add('visible');
            return;
          }
        }
      }
    }

    function gameLoop() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawRoad();
      drawEnemies();
      drawBullets();
      drawPlayer();
      drawFlash();
      update();
      if (!gameOver) animationId = requestAnimationFrame(gameLoop);
    }

    function fireBullet() {
      if (gameOver) return;
      const now = Date.now();
      if (now - lastShotAt < fireCooldownMs) return;
      lastShotAt = now;
      const x = playerX + playerWidth / 2 - bulletWidth / 2;
      const y = playerY;
      bullets.push({ x, y, width: bulletWidth, height: bulletHeight });
    }

    document.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowLeft') { keys.left = true; e.preventDefault(); }
      if (e.key === 'ArrowRight') { keys.right = true; e.preventDefault(); }
      if (e.key === ' ') { fireBullet(); e.preventDefault(); }
    });
    document.addEventListener('keyup', (e) => {
      if (e.key === 'ArrowLeft') keys.left = false;
      if (e.key === 'ArrowRight') keys.right = false;
    });

    gameLoop();
  </script>
</body>
</html>
